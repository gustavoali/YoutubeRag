# E2E Testing Pipeline with Playwright
# Runs end-to-end tests against the API
name: E2E Tests

on:
  push:
    branches: [ develop, master ]
  pull_request:
    branches: [ develop, master ]
    types: [opened, synchronize, reopened]
  workflow_dispatch:
  schedule:
    # Run E2E tests daily at 2 AM UTC
    - cron: '0 2 * * *'

env:
  DOTNET_VERSION: '8.0.x'
  DOTNET_SKIP_FIRST_TIME_EXPERIENCE: 1
  DOTNET_NOLOGO: true
  DOTNET_CLI_TELEMETRY_OPTOUT: 1

jobs:
  e2e-tests:
    name: End-to-End Tests
    runs-on: ubuntu-latest
    timeout-minutes: 30

    # Service containers
    services:
      mysql:
        image: mysql:8.0
        env:
          MYSQL_ROOT_PASSWORD: e2e_password
          MYSQL_DATABASE: youtube_rag_test_e2e
          MYSQL_USER: youtube_rag_user
          MYSQL_PASSWORD: youtube_rag_password
        ports:
          - 3306:3306
        options: >-
          --health-cmd="mysqladmin ping"
          --health-interval=10s
          --health-timeout=5s
          --health-retries=5

      redis:
        image: redis:7-alpine
        ports:
          - 6379:6379
        options: >-
          --health-cmd="redis-cli ping"
          --health-interval=10s
          --health-timeout=5s
          --health-retries=5

    steps:
      # Checkout code
      - name: Checkout Code
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      # Setup .NET
      - name: Setup .NET ${{ env.DOTNET_VERSION }}
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}

      # Cache dependencies
      - name: Cache NuGet Packages
        uses: actions/cache@v3
        with:
          path: ~/.nuget/packages
          key: ${{ runner.os }}-nuget-e2e-${{ hashFiles('**/packages.lock.json', '**/*.csproj') }}
          restore-keys: |
            ${{ runner.os }}-nuget-e2e-
            ${{ runner.os }}-nuget-

      # Install Playwright
      - name: Install Playwright CLI
        run: |
          dotnet tool install --global Microsoft.Playwright.CLI || dotnet tool update --global Microsoft.Playwright.CLI

      # Restore and build
      - name: Restore Dependencies
        run: dotnet restore YoutubeRag.sln

      - name: Build Solution
        run: dotnet build YoutubeRag.sln --configuration Release --no-restore

      # Install Playwright browsers
      - name: Install Playwright Browsers
        run: |
          export PATH="$PATH:$HOME/.dotnet/tools"
          echo "Installing Playwright browsers..."
          playwright install --with-deps chromium

          # Verify installation
          echo "Verifying Playwright installation..."
          if playwright show-devices 2>&1 | grep -q chromium; then
            echo "✓ Playwright installed successfully"
          else
            echo "::warning::Could not verify Playwright installation, continuing anyway..."
          fi

      # Verify service containers are ready
      - name: Verify Service Containers
        run: |
          echo "Verifying MySQL is ready..."
          for i in {1..30}; do
            if mysqladmin ping -h 127.0.0.1 -P 3306 -u youtube_rag_user -pyoutube_rag_password --silent 2>/dev/null; then
              echo "✓ MySQL is ready"
              break
            fi
            echo "Waiting for MySQL... ($i/30)"
            sleep 2
          done

          echo "Verifying Redis is ready..."
          for i in {1..30}; do
            if redis-cli -h localhost -p 6379 ping 2>/dev/null | grep -q PONG; then
              echo "✓ Redis is ready"
              break
            fi
            echo "Waiting for Redis... ($i/30)"
            sleep 2
          done

          # Final check
          if ! mysqladmin ping -h 127.0.0.1 -P 3306 -u youtube_rag_user -pyoutube_rag_password --silent; then
            echo "::error::MySQL is not ready"
            exit 1
          fi

          if ! redis-cli -h localhost -p 6379 ping | grep -q PONG; then
            echo "::error::Redis is not ready"
            exit 1
          fi

          echo "✅ All service containers are ready"

      # Apply migrations
      - name: Apply Database Migrations
        env:
          ConnectionStrings__DefaultConnection: "Server=localhost;Port=3306;Database=youtube_rag_test_e2e;Uid=youtube_rag_user;Pwd=youtube_rag_password;AllowPublicKeyRetrieval=True;"
        run: |
          dotnet tool install --global dotnet-ef --version 8.0.0 || dotnet tool update --global dotnet-ef --version 8.0.0
          export PATH="$PATH:$HOME/.dotnet/tools"

          echo "Applying database migrations..."
          dotnet ef database update \
            --project YoutubeRag.Infrastructure \
            --startup-project YoutubeRag.Api \
            --configuration Release \
            --no-build \
            --verbose

      # Start API server
      - name: Start API Server
        env:
          ConnectionStrings__DefaultConnection: "Server=localhost;Port=3306;Database=youtube_rag_test_e2e;Uid=youtube_rag_user;Pwd=youtube_rag_password;AllowPublicKeyRetrieval=True;"
          ConnectionStrings__Redis: "localhost:6379"
          JwtSettings__SecretKey: "E2ETestSecretKeyForJWTTokenGenerationMinimum256BitsLong!"
          JwtSettings__ExpirationInMinutes: "60"
          JwtSettings__RefreshTokenExpirationInDays: "7"
          ASPNETCORE_ENVIRONMENT: "Testing"
          AppSettings__Environment: "Testing"
          AppSettings__ProcessingMode: "Mock"
          AppSettings__StorageMode: "Database"
          AppSettings__EnableAuth: "true"
          AppSettings__EnableWebSockets: "false"
          AppSettings__EnableMetrics: "false"
          AppSettings__EnableRealProcessing: "false"
          AppSettings__EnableDocs: "true"
          AppSettings__EnableCors: "true"
          AppSettings__EnableBackgroundJobs: "false"
          ASPNETCORE_URLS: "http://localhost:5000"
        run: |
          cd YoutubeRag.Api
          echo "Starting API server..."
          dotnet run --no-build --configuration Release > api.log 2>&1 &
          API_PID=$!
          echo "API_PID=$API_PID" >> $GITHUB_ENV
          echo "API started with PID: $API_PID"

          # Wait for API to be ready with enhanced health checking
          echo "Waiting for API to start (up to 90 seconds)..."
          MAX_ATTEMPTS=45
          ATTEMPT=0

          while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
            ATTEMPT=$((ATTEMPT + 1))

            # Check if process is still running
            if ! kill -0 $API_PID 2>/dev/null; then
              echo "::error::API process died unexpectedly"
              echo "=== API Logs ==="
              cat api.log
              exit 1
            fi

            # Try to connect to health endpoint
            HTTP_CODE=$(curl -s -o /tmp/health_response.json -w "%{http_code}" http://localhost:5000/health 2>/dev/null || echo "000")

            if [ "$HTTP_CODE" = "200" ]; then
              echo "✓ API health check passed (attempt $ATTEMPT/$MAX_ATTEMPTS)"
              echo "Health response:"
              cat /tmp/health_response.json | jq '.' 2>/dev/null || cat /tmp/health_response.json

              # Additional verification: check if API is truly ready
              echo "Verifying API endpoints..."
              if curl -s http://localhost:5000/ > /dev/null 2>&1; then
                echo "✓ API root endpoint responding"
                echo "API is fully ready!"
                break
              else
                echo "⚠ Health check passed but root endpoint not responding yet"
              fi
            elif [ "$HTTP_CODE" = "503" ]; then
              echo "⚠ API returned 503 (Service Unavailable) - some components not ready yet (attempt $ATTEMPT/$MAX_ATTEMPTS)"
              cat /tmp/health_response.json | jq '.' 2>/dev/null || cat /tmp/health_response.json
            elif [ "$HTTP_CODE" = "000" ]; then
              echo "⏳ API not responding yet (attempt $ATTEMPT/$MAX_ATTEMPTS)"
            else
              echo "⚠ API returned HTTP $HTTP_CODE (attempt $ATTEMPT/$MAX_ATTEMPTS)"
            fi

            sleep 2
          done

          # Final verification
          HTTP_CODE=$(curl -s -o /tmp/health_final.json -w "%{http_code}" http://localhost:5000/health 2>/dev/null || echo "000")
          if [ "$HTTP_CODE" != "200" ]; then
            echo "::error::API failed to become healthy after $MAX_ATTEMPTS attempts"
            echo "=== Final Health Check Response (HTTP $HTTP_CODE) ==="
            cat /tmp/health_final.json 2>/dev/null || echo "No response"
            echo ""
            echo "=== API Logs ==="
            cat api.log
            exit 1
          fi

          echo "✅ API is healthy and ready for testing"

      # Run E2E tests
      - name: Run E2E Tests
        env:
          TestSettings__BaseUrl: "http://localhost:5000"
          TestSettings__ApiBaseUrl: "http://localhost:5000/api/v1"
          TestSettings__Headless: "true"
          TestSettings__ScreenshotOnFailure: "true"
          TestSettings__VideoRecording: "true"
          TestSettings__TestTimeout: "30000"
        run: |
          dotnet test YoutubeRag.Tests.E2E/YoutubeRag.Tests.E2E.csproj \
            --configuration Release \
            --no-build \
            --verbosity normal \
            --logger "trx;LogFileName=e2e-results.trx" \
            --logger "console;verbosity=detailed" \
            --settings YoutubeRag.Tests.E2E/.runsettings \
            --results-directory ./TestResults/E2E

      # Upload API logs on failure
      - name: Upload API Logs
        uses: actions/upload-artifact@v4
        if: failure()
        with:
          name: api-logs
          path: YoutubeRag.Api/api.log
          retention-days: 30

      # Stop API server
      - name: Stop API Server
        if: always()
        run: |
          if [ ! -z "${{ env.API_PID }}" ]; then
            echo "Stopping API server (PID: ${{ env.API_PID }})"
            kill ${{ env.API_PID }} || true
            # Wait for graceful shutdown
            sleep 2
            # Force kill if still running
            kill -9 ${{ env.API_PID }} 2>/dev/null || true
            echo "API server stopped"
          fi

      # Upload test results
      - name: Upload E2E Test Results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: e2e-test-results
          path: |
            TestResults/E2E/**/*.trx
            TestResults/E2E/**/*.xml
            TestResults/E2E/**/report.html
          retention-days: 30

      # Upload screenshots and traces on failure
      - name: Upload Test Artifacts on Failure
        uses: actions/upload-artifact@v4
        if: failure()
        with:
          name: e2e-test-artifacts
          path: |
            TestResults/Screenshots/
            TestResults/Videos/
            TestResults/*.zip
          retention-days: 30

      # Create test summary
      - name: Create Test Summary
        if: always()
        run: |
          echo "## E2E Test Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          if [ -f "TestResults/E2E/e2e-results.trx" ]; then
            # Parse TRX file for summary (simplified)
            echo "✅ E2E tests completed" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "Check artifacts for detailed results" >> $GITHUB_STEP_SUMMARY
          else
            echo "❌ E2E test results not found" >> $GITHUB_STEP_SUMMARY
          fi

      # Publish test report
      - name: Publish E2E Test Report
        uses: dorny/test-reporter@v1
        if: always()
        with:
          name: E2E Test Report
          path: TestResults/E2E/*.trx
          reporter: dotnet-trx
          fail-on-error: false
